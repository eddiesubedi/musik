<!DOCTYPE html>
<html>
<head>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #0a0a0a; overflow: hidden; touch-action: none; user-select: none; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; font-family: 'Courier New', monospace;
        }
        #score {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 24px; letter-spacing: 2px;
        }
        #pursuer-dist {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            color: #ff4444; font-size: 14px; letter-spacing: 1px;
        }
        #controls {
            position: absolute; bottom: 20px; width: 100%; display: flex;
            justify-content: space-around; pointer-events: all;
        }
        .btn {
            width: 45%; height: 80px; border: 2px solid #555; border-radius: 8px;
            background: rgba(255,255,255,0.05); color: #aaa; font-size: 18px;
            font-family: 'Courier New', monospace; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: background 0.05s, border-color 0.05s;
        }
        .btn:active { background: rgba(255,255,255,0.15); border-color: #fff; color: #fff; }
        #start-screen, #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #fff; font-family: 'Courier New', monospace; pointer-events: all;
            background: rgba(0,0,0,0.85);
        }
        #start-screen h1, #death-screen h1 { font-size: 28px; margin-bottom: 10px; }
        #start-screen p, #death-screen p { color: #888; font-size: 14px; margin-bottom: 5px; }
        .start-btn {
            margin-top: 20px; padding: 12px 40px; border: 2px solid #fff;
            background: none; color: #fff; font-size: 18px; cursor: pointer;
            font-family: 'Courier New', monospace; border-radius: 4px;
        }
        .start-btn:hover { background: rgba(255,255,255,0.1); }
        #death-score { color: #ff4444; font-size: 36px; margin: 10px 0; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
    <div id="score">0</div>
    <div id="pursuer-dist"></div>
    <div id="controls">
        <div class="btn" id="btn-turn">TURN</div>
        <div class="btn" id="btn-go">GO</div>
    </div>
</div>
<div id="start-screen">
    <h1>MAZE RUNNER</h1>
    <p>You auto-advance through a maze path.</p>
    <p><b>GO</b> = keep moving forward</p>
    <p><b>TURN</b> = rotate 90Â° and advance</p>
    <p>The path turns at random. Stay on it.</p>
    <p>Something is chasing you. Don't stop.</p>
    <button class="start-btn" id="start-btn">START</button>
</div>
<div id="death-screen" style="display:none">
    <h1>CAUGHT</h1>
    <div id="death-score">0</div>
    <p>steps survived</p>
    <button class="start-btn" id="restart-btn">AGAIN</button>
</div>

<script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const pursuerEl = document.getElementById('pursuer-dist');
    const startScreen = document.getElementById('start-screen');
    const deathScreen = document.getElementById('death-screen');

    let W, H, CELL;
    function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        CELL = Math.min(W, H) / 18;
    }
    resize();
    window.addEventListener('resize', resize);

    // Directions: 0=up, 1=right, 2=down, 3=left
    const DX = [0, 1, 0, -1];
    const DY = [-1, 0, 1, 0];

    let state = 'start';
    let path = [];
    let playerIdx = 0;
    let playerDir = 0;
    let pursuerIdx = 0;
    let steps = 0;
    let speed = 400;
    let lastStep = 0;
    let pursuerSpeed = 450;
    let lastPursuerStep = 0;
    let shakeX = 0, shakeY = 0;
    let flashAlpha = 0;
    let deathFlash = 0;
    let cameraX = 0, cameraY = 0;
    let targetCamX = 0, targetCamY = 0;

    function generatePath(startX, startY, startDir, length) {
        let p = [];
        let x = startX, y = startY, dir = startDir;
        p.push({ x, y, dir });
        for (let i = 0; i < length; i++) {
            // Decide: continue straight or turn
            let r = Math.random();
            let minStraight = Math.max(1, 4 - Math.floor(steps / 80));
            let straightCount = 0;
            for (let j = p.length - 1; j >= 0; j--) {
                if (p[j].dir === dir) straightCount++;
                else break;
            }
            if (straightCount < minStraight) {
                // Force straight
            } else if (r < 0.35) {
                // Turn left or right
                dir = (dir + (Math.random() < 0.5 ? 1 : 3)) % 4;
            }
            x += DX[dir];
            y += DY[dir];
            p.push({ x, y, dir });
        }
        return p;
    }

    function initGame() {
        path = generatePath(0, 0, 0, 300);
        playerIdx = 0;
        playerDir = path[1] ? path[1].dir : 0;
        pursuerIdx = -15;
        steps = 0;
        speed = 380;
        pursuerSpeed = 4440;
        lastStep = performance.now();
        lastPursuerStep = performance.now();
        shakeX = 0; shakeY = 0;
        flashAlpha = 0;
        deathFlash = 0;
        state = 'playing';
        startScreen.style.display = 'none';
        deathScreen.style.display = 'none';
    }

    function extendPath() {
        if (playerIdx > path.length - 60) {
            let last = path[path.length - 1];
            let ext = generatePath(last.x + DX[last.dir], last.y + DY[last.dir], last.dir, 150);
            path = path.concat(ext);
        }
    }

    function playerGo() {
        if (state !== 'playing') return;
        let nextIdx = playerIdx + 1;
        if (nextIdx >= path.length) return;

        let nextCell = path[nextIdx];
        let expectedDir = nextCell.dir;
        // Check if current direction matches what's needed
        // The path stores the direction you ARRIVED from
        // We need to check: does our current facing match the direction to get to nextCell?
        let neededDX = nextCell.x - path[playerIdx].x;
        let neededDY = nextCell.y - path[playerIdx].y;
        let neededDir;
        if (neededDX === 1) neededDir = 1;
        else if (neededDX === -1) neededDir = 3;
        else if (neededDY === -1) neededDir = 0;
        else neededDir = 2;

        if (playerDir === neededDir) {
            playerIdx = nextIdx;
            steps++;
            lastStep = performance.now();

            // Speed up
            speed = Math.max(120, 380 - steps * 0.8);
            pursuerSpeed = Math.max(140, 440 - steps * 0.6);

            scoreEl.textContent = steps;
            extendPath();
        } else {
            // Wrong direction! Wall hit
            wallHit();
        }
    }

    function playerTurn() {
        if (state !== 'playing') return;
        // Rotate 90 degrees clockwise and advance
        playerDir = (playerDir + 1) % 4;

        let nextIdx = playerIdx + 1;
        if (nextIdx >= path.length) return;

        let nextCell = path[nextIdx];
        let neededDX = nextCell.x - path[playerIdx].x;
        let neededDY = nextCell.y - path[playerIdx].y;
        let neededDir;
        if (neededDX === 1) neededDir = 1;
        else if (neededDX === -1) neededDir = 3;
        else if (neededDY === -1) neededDir = 0;
        else neededDir = 2;

        if (playerDir === neededDir) {
            playerIdx = nextIdx;
            steps++;
            lastStep = performance.now();

            speed = Math.max(120, 380 - steps * 0.8);
            pursuerSpeed = Math.max(140, 440 - steps * 0.6);

            scoreEl.textContent = steps;
            extendPath();
        } else {
            wallHit();
        }
    }

    function wallHit() {
        shakeX = (Math.random() - 0.5) * 10;
        shakeY = (Math.random() - 0.5) * 10;
        flashAlpha = 0.3;
        // Pursuer gains ground
        pursuerIdx = Math.min(pursuerIdx + 3, playerIdx);
    }

    function die() {
        state = 'dead';
        deathFlash = 1;
        document.getElementById('death-score').textContent = steps;
        setTimeout(() => {
            deathScreen.style.display = 'flex';
        }, 500);
    }

    function update(now) {
        if (state !== 'playing') return;

        // Auto-pressure: if player hasn't moved, pursuer still advances
        if (now - lastPursuerStep > pursuerSpeed && pursuerIdx < playerIdx) {
            pursuerIdx = Math.min(pursuerIdx + 1, playerIdx - 1);
            lastPursuerStep = now;
        }

        // Check if caught
        if (pursuerIdx >= playerIdx) {
            die();
            return;
        }

        // Decay effects
        shakeX *= 0.85;
        shakeY *= 0.85;
        flashAlpha *= 0.9;

        // Update pursuer distance indicator
        let dist = playerIdx - pursuerIdx;
        let bar = '';
        let maxDist = 20;
        let shown = Math.min(dist, maxDist);
        for (let i = 0; i < shown; i++) bar += '|';
        pursuerEl.textContent = dist <= 8 ? `CLOSE [${bar}]` : `[${bar}]`;
        pursuerEl.style.color = dist <= 5 ? '#ff0000' : dist <= 10 ? '#ff4444' : '#666';
    }

    function draw() {
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(0, 0, W, H);

        if (state === 'start') { requestAnimationFrame(draw); return; }

        let playerPos = path[playerIdx];
        if (!playerPos) { requestAnimationFrame(draw); return; }

        // Camera follows player
        targetCamX = playerPos.x * CELL;
        targetCamY = playerPos.y * CELL;
        cameraX += (targetCamX - cameraX) * 0.15;
        cameraY += (targetCamY - cameraY) * 0.15;

        ctx.save();
        ctx.translate(W/2 - cameraX + shakeX, H/2 - cameraY + shakeY);

        // Draw path
        let drawStart = Math.max(0, playerIdx - 30);
        let drawEnd = Math.min(path.length - 1, playerIdx + 40);

        for (let i = drawStart; i <= drawEnd; i++) {
            let cell = path[i];
            let distFromPlayer = i - playerIdx;
            let alpha;
            if (distFromPlayer < 0) {
                alpha = Math.max(0.05, 0.3 + distFromPlayer * 0.01);
            } else {
                alpha = Math.max(0.08, 0.5 - distFromPlayer * 0.012);
            }

            // Path cell
            ctx.fillStyle = `rgba(40, 40, 50, ${alpha})`;
            ctx.fillRect(cell.x * CELL - CELL/2, cell.y * CELL - CELL/2, CELL, CELL);

            // Path border/glow
            if (distFromPlayer >= 0 && distFromPlayer < 20) {
                ctx.strokeStyle = `rgba(100, 140, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 1;
                ctx.strokeRect(cell.x * CELL - CELL/2, cell.y * CELL - CELL/2, CELL, CELL);
            }

            // Show turn indicators ahead
            if (i > playerIdx && i < playerIdx + 15 && i + 1 < path.length) {
                let curr = path[i];
                let next = path[i + 1];
                let cdx = next.x - curr.x;
                let cdy = next.y - curr.y;
                let pdx = curr.x - path[i-1].x;
                let pdy = curr.y - path[i-1].y;
                if (cdx !== pdx || cdy !== pdy) {
                    // Turn point
                    ctx.fillStyle = `rgba(255, 200, 80, ${alpha * 0.6})`;
                    ctx.beginPath();
                    ctx.arc(curr.x * CELL, curr.y * CELL, CELL * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Draw pursuer
        if (pursuerIdx >= 0 && pursuerIdx >= drawStart && pursuerIdx <= drawEnd) {
            let pCell = path[pursuerIdx];
            let dist = playerIdx - pursuerIdx;
            let pulse = Math.sin(performance.now() / 150) * 0.3 + 0.7;
            let size = CELL * 0.35;

            ctx.fillStyle = `rgba(255, 30, 30, ${pulse})`;
            ctx.beginPath();
            ctx.arc(pCell.x * CELL, pCell.y * CELL, size, 0, Math.PI * 2);
            ctx.fill();

            // Pursuer glow
            ctx.fillStyle = `rgba(255, 0, 0, ${pulse * 0.15})`;
            ctx.beginPath();
            ctx.arc(pCell.x * CELL, pCell.y * CELL, size * 2.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Draw player
        let px = playerPos.x * CELL;
        let py = playerPos.y * CELL;

        // Direction indicator
        let angle = playerDir * Math.PI / 2 - Math.PI / 2;

        // Player glow
        ctx.fillStyle = 'rgba(100, 200, 255, 0.1)';
        ctx.beginPath();
        ctx.arc(px, py, CELL * 0.6, 0, Math.PI * 2);
        ctx.fill();

        // Player body
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(px, py, CELL * 0.25, 0, Math.PI * 2);
        ctx.fill();

        // Direction arrow
        ctx.strokeStyle = '#6af';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + Math.cos(angle) * CELL * 0.4, py + Math.sin(angle) * CELL * 0.4);
        ctx.stroke();

        ctx.restore();

        // Red flash on wall hit
        if (flashAlpha > 0.01) {
            ctx.fillStyle = `rgba(255, 0, 0, ${flashAlpha})`;
            ctx.fillRect(0, 0, W, H);
        }

        // Death flash
        if (deathFlash > 0.01) {
            ctx.fillStyle = `rgba(255, 0, 0, ${deathFlash})`;
            ctx.fillRect(0, 0, W, H);
            deathFlash *= 0.95;
        }

        update(performance.now());
        requestAnimationFrame(draw);
    }

    // Input
    document.getElementById('btn-go').addEventListener('pointerdown', e => {
        e.preventDefault();
        playerGo();
    });
    document.getElementById('btn-turn').addEventListener('pointerdown', e => {
        e.preventDefault();
        playerTurn();
    });

    document.addEventListener('keydown', e => {
        if (e.repeat) return;
        if (e.key === 'ArrowRight' || e.key === 'd' || e.key === ' ') playerGo();
        if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'Shift') playerTurn();
    });

    document.getElementById('start-btn').addEventListener('click', initGame);
    document.getElementById('restart-btn').addEventListener('click', initGame);

    requestAnimationFrame(draw);
</script>
</body>
</html>