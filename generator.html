<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JSON to Gleam Model Generator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #1a1a2e;
      color: #e0e0e0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 16px 24px;
      background: #16213e;
      border-bottom: 1px solid #0f3460;
      display: flex;
      align-items: center;
      gap: 16px;
    }
    header h1 {
      font-size: 18px;
      font-weight: 600;
      color: #ffcbcb;
    }
    header input {
      padding: 6px 12px;
      background: #1a1a2e;
      border: 1px solid #0f3460;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 14px;
      width: 200px;
    }
    header label {
      font-size: 13px;
      color: #a0a0b8;
    }
    .container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }
    .panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .panel-header {
      padding: 10px 16px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: #a0a0b8;
      background: #16213e;
      border-bottom: 1px solid #0f3460;
    }
    .divider {
      width: 1px;
      background: #0f3460;
    }
    pre {
      flex: 1;
      padding: 16px;
      font-family: 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
      font-size: 13px;
      line-height: 1.6;
      border: none;
      outline: none;
      resize: none;
      overflow: auto;
    }
    pre {
      background: #12122a;
      color: #e0e0e0;
      margin: 0;
      white-space: pre;
    }
    .error { color: #ff6b6b; }
    .kw { color: #ffcbcb; }
    .type { color: #a8d8ea; }
    .field { color: #e0e0e0; }
    .comment { color: #6a6a8a; }
    .action-btn {
      padding: 4px 12px;
      background: #0f3460;
      border: 1px solid #1a5276;
      border-radius: 4px;
      color: #a0a0b8;
      font-size: 12px;
      cursor: pointer;
    }
    .action-btn:hover { background: #1a5276; color: #e0e0e0; }
    .copy-btn {
      position: absolute;
      top: 8px;
      right: 16px;
    }
    .output-wrap { position: relative; flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .panel-header { display: flex; align-items: center; gap: 8px; }
    .panel-header-title { flex: 1; }
    .json-editor-wrap {
      flex: 1;
      overflow: hidden;
      position: relative;
      --jse-theme-color: #0f3460;
      --jse-theme-color-highlight: #1a5276;
      --jse-background-color: #1a1a2e;
      --jse-panel-background: #16213e;
      --jse-text-color: #e0e0e0;
      --jse-text-color-inverse: #1a1a2e;
      --jse-error-color: #ff6b6b;
      --jse-key-color: #a8d8ea;
      --jse-value-color-string: #98c379;
      --jse-value-color-number: #d19a66;
      --jse-value-color-boolean: #ffcbcb;
      --jse-value-color-null: #6a6a8a;
      --jse-delimiter-color: #6a6a8a;
      --jse-selection-background-color: #1a5276;
      --jse-selection-background-inactive-color: #0f3460;
      --jse-context-menu-background: #16213e;
      --jse-context-menu-color: #e0e0e0;
      --jse-menu-color: #a0a0b8;
    }
    .json-editor-wrap #jsoneditor {
      height: 100%;
    }
  </style>
</head>
<body>
  <header>
    <h1>JSON &rarr; Gleam</h1>
    <label>Root type name:</label>
    <input type="text" id="rootName" value="Root" spellcheck="false">
  </header>
  <div class="container">
    <div class="panel">
      <div class="panel-header">
        <span class="panel-header-title">JSON Input</span>
        <button class="action-btn" id="formatBtn">Format</button>
      </div>
      <div class="json-editor-wrap">
        <div id="jsoneditor"></div>
      </div>
    </div>
    <div class="divider"></div>
    <div class="panel">
      <div class="panel-header">
        <span class="panel-header-title">Gleam Model</span>
      </div>
      <div class="output-wrap">
        <button class="action-btn copy-btn" id="copyBtn">Copy</button>
        <pre id="output"></pre>
      </div>
    </div>
  </div>

  <script type="module">
    import { JSONEditor } from 'https://cdn.jsdelivr.net/npm/vanilla-jsoneditor@2/standalone.js';

    const output = document.getElementById('output');
    const rootNameInput = document.getElementById('rootName');
    const copyBtn = document.getElementById('copyBtn');
    const formatBtn = document.getElementById('formatBtn');

    let currentJson = {};

    const editor = new JSONEditor({
      target: document.getElementById('jsoneditor'),
      props: {
        mode: 'tree',
        mainMenuBar: false,
        navigationBar: false,
        content: { json: {} },
        onChange: (content) => {
          try {
            currentJson = content.json ?? JSON.parse(content.text);
            updateGleam();
          } catch (e) {}
        },
      },
    });

    formatBtn.addEventListener('click', () => {
      try {
        editor.set({ json: currentJson });
      } catch (e) {}
    });

    function pascalCase(str) {
      return str
        .replace(/[^a-zA-Z0-9]+(.)/g, (_, c) => c.toUpperCase())
        .replace(/^[a-z]/, c => c.toUpperCase());
    }

    const RESERVED = new Set([
      'as', 'assert', 'auto', 'case', 'const', 'delegate', 'derive',
      'echo', 'else', 'fn', 'if', 'implement', 'import', 'let',
      'macro', 'opaque', 'panic', 'pub', 'test', 'todo', 'type', 'use',
    ]);

    function snakeCase(str) {
      let name = str
        .replace(/([a-z0-9])([A-Z])/g, '$1_$2')
        .replace(/[^a-zA-Z0-9]+/g, '_')
        .toLowerCase()
        .replace(/^_|_$/g, '');
      if (RESERVED.has(name)) name = name + '_';
      return name;
    }

    function gleamType(value, key, types, parentName) {
      if (value === null || value === undefined) {
        return 'Option(String)';
      }
      if (typeof value === 'string') return 'String';
      if (typeof value === 'boolean') return 'Bool';
      if (typeof value === 'number') {
        return Number.isInteger(value) ? 'Int' : 'Float';
      }
      if (Array.isArray(value)) {
        if (value.length === 0) return 'List(String)';
        // For arrays of objects, merge all elements to find optional fields
        if (typeof value[0] === 'object' && value[0] !== null && !Array.isArray(value[0])) {
          const typeName = pascalCase(key || 'Anonymous');
          generateTypeFromArray(typeName, value, types);
          return `List(${typeName})`;
        }
        const inner = gleamType(value[0], key, types, parentName);
        return `List(${inner})`;
      }
      if (typeof value === 'object') {
        const typeName = pascalCase(key || 'Anonymous');
        generateType(typeName, value, types);
        return typeName;
      }
      return 'String';
    }

    function isCustomType(t) {
      return !['String', 'Int', 'Float', 'Bool'].includes(t)
        && !t.startsWith('List(') && !t.startsWith('Option(');
    }

    // Scan ALL array elements to detect which fields are optional
    function generateTypeFromArray(name, arr, types) {
      if (types.has(name)) return;
      types.set(name, null);

      // Collect all keys across all elements
      const allKeys = new Set();
      const keyCounts = {};
      const bestSamples = {};  // first non-null/undefined value per key
      const hasFloat = {};     // true if ANY element has a non-integer number
      for (const item of arr) {
        if (typeof item !== 'object' || item === null) continue;
        for (const key of Object.keys(item)) {
          allKeys.add(key);
          keyCounts[key] = (keyCounts[key] || 0) + 1;
          // Track best value for type inference — prefer non-empty arrays
          if (item[key] !== null && item[key] !== undefined) {
            const cur = bestSamples[key];
            if (cur === undefined
              || (Array.isArray(cur) && cur.length === 0 && Array.isArray(item[key]) && item[key].length > 0)) {
              bestSamples[key] = item[key];
            }
          }
          // Track if any number value is non-integer (JS eats 6.0 → 6)
          if (typeof item[key] === 'number' && !Number.isInteger(item[key])) {
            hasFloat[key] = true;
          }
        }
      }

      const fields = [];
      for (const key of allKeys) {
        const fieldName = snakeCase(key);
        const sampleValue = key in bestSamples ? bestSamples[key] : null;
        let fieldType = gleamType(sampleValue, key, types, name);
        // If ANY element had a non-integer, override Int → Float
        if (hasFloat[key] && fieldType === 'Int') {
          fieldType = 'Float';
        }
        const optional = keyCounts[key] < arr.length;
        // Custom types have no sensible default — wrap optional ones in Option()
        if (optional && isCustomType(fieldType)) {
          fieldType = `Option(${fieldType})`;
        }
        fields.push({ name: fieldName, jsonKey: key, type: fieldType, optional });
      }

      types.set(name, fields);
    }

    function generateType(name, obj, types) {
      // Avoid duplicates
      if (types.has(name)) return;
      types.set(name, null); // placeholder to prevent recursion

      const fields = [];
      for (const [key, value] of Object.entries(obj)) {
        const fieldName = snakeCase(key);
        const fieldType = gleamType(value, key, types, name);
        fields.push({ name: fieldName, jsonKey: key, type: fieldType, optional: false });
      }

      types.set(name, fields);
    }

    function generate(json, rootName) {
      const types = new Map();
      const root = pascalCase(rootName || 'Root');

      if (Array.isArray(json)) {
        if (json.length > 0 && typeof json[0] === 'object' && json[0] !== null) {
          generateTypeFromArray(root, json, types);
          return { types, note: `/// Top-level is List(${root})` };
        }
        return { types: new Map(), note: '/// Top-level is a List' };
      }

      generateType(root, json, types);
      return { types, note: null };
    }

    function decoderForType(fieldType, optional = false) {
      if (fieldType === 'String') return optional ? 'nullable_string()' : 'decode.string';
      if (fieldType === 'Int') return 'decode.int';
      if (fieldType === 'Float') return 'decode.float';
      if (fieldType === 'Bool') return 'decode.bool';
      if (fieldType === 'Option(String)') return 'decode.optional(decode.string)';
      if (fieldType.startsWith('Option(')) {
        const inner = fieldType.slice(7, -1);
        return `decode.optional(${decoderForType(inner)})`;
      }
      if (fieldType.startsWith('List(')) {
        const inner = fieldType.slice(5, -1);
        const listDec = `decode.list(${decoderForType(inner)})`;
        return optional ? `decode.one_of(${listDec}, or: [decode.success([])])` : listDec;
      }
      // It's a custom type — use its decoder function
      const fnName = snakeCase(fieldType) + '_decoder()';
      return fnName;
    }

    function defaultForType(fieldType) {
      if (fieldType === 'String') return '""';
      if (fieldType === 'Int') return '0';
      if (fieldType === 'Float') return '0.0';
      if (fieldType === 'Bool') return 'False';
      if (fieldType.startsWith('List(')) return '[]';
      if (fieldType.startsWith('Option(')) return 'option.None';
      return '""';
    }

    function renderTypes(types, note) {
      let lines = [];

      if (note) {
        lines.push(`<span class="comment">${escHtml(note)}</span>\n`);
      }

      // --- Types ---
      lines.push(`<span class="comment">// --- Types ---</span>\n`);
      for (const [name, fields] of types) {
        lines.push(`<span class="kw">pub type</span> <span class="type">${escHtml(name)}</span> {`);

        const fieldLines = fields.map(f =>
          `    <span class="field">${escHtml(f.name)}</span>: <span class="type">${escHtml(f.type)}</span>,`
        );

        lines.push(`  <span class="type">${escHtml(name)}</span>(`);
        lines.push(fieldLines.join('\n'));
        lines.push('  )');
        lines.push('}\n');
      }

      // --- Helpers ---
      // Check if any optional string/list fields exist
      let needsNullableString = false;
      for (const [, fields] of types) {
        for (const f of fields) {
          if (f.optional && f.type === 'String') needsNullableString = true;
        }
      }
      if (needsNullableString) {
        lines.push(`<span class="comment">/// Accepts a string or null, returns "" for null</span>`);
        lines.push(`<span class="kw">fn</span> <span class="field">nullable_string</span>() -> <span class="type">decode.Decoder</span>(<span class="type">String</span>) {`);
        lines.push(`  <span class="type">decode.one_of</span>(<span class="type">decode.string</span>, <span class="field">or:</span> [<span class="type">decode.success</span>(<span class="comment">""</span>)])`);
        lines.push('}\n');
      }

      // --- Decoders ---
      lines.push(`<span class="comment">// --- Decoders ---</span>\n`);
      for (const [name, fields] of types) {
        const fnName = snakeCase(name) + '_decoder';
        lines.push(`<span class="kw">pub fn</span> <span class="field">${escHtml(fnName)}</span>() -> <span class="type">decode.Decoder</span>(<span class="type">${escHtml(name)}</span>) {`);

        for (const f of fields) {
          const dec = decoderForType(f.type, f.optional);
          if (f.optional) {
            const def = defaultForType(f.type);
            lines.push(`  <span class="kw">use</span> <span class="field">${escHtml(f.name)}</span> <span class="kw">&lt;-</span> <span class="type">decode.optional_field</span>(<span class="comment">"${escHtml(f.jsonKey)}"</span>, ${escHtml(def)}, ${escHtml(dec)})`);
          } else {
            lines.push(`  <span class="kw">use</span> <span class="field">${escHtml(f.name)}</span> <span class="kw">&lt;-</span> <span class="type">decode.field</span>(<span class="comment">"${escHtml(f.jsonKey)}"</span>, ${escHtml(dec)})`);
          }
        }

        lines.push(`  <span class="type">decode.success</span>(<span class="type">${escHtml(name)}</span>(${fields.map(f => escHtml(f.name) + ':').join(', ')}))`);
        lines.push('}\n');
      }

      return lines.join('\n');
    }

    function escHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function updateGleam() {
      try {
        const { types, note } = generate(currentJson, rootNameInput.value);
        output.innerHTML = renderTypes(types, note);
      } catch (e) {
        output.innerHTML = `<span class="error">// Error: ${escHtml(e.message)}</span>`;
      }
    }

    rootNameInput.addEventListener('input', updateGleam);

    copyBtn.addEventListener('click', () => {
      const text = output.textContent || output.innerText;
      navigator.clipboard.writeText(text).then(() => {
        copyBtn.textContent = 'Copied!';
        setTimeout(() => { copyBtn.textContent = 'Copy'; }, 1500);
      });
    });

    updateGleam();
  </script>
</body>
</html>
